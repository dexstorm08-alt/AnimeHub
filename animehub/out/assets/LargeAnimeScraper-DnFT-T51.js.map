{"version":3,"file":"LargeAnimeScraper-DnFT-T51.js","sources":["../../src/services/largeAnimeScraperService.ts","../../src/components/admin/LargeAnimeScraper.tsx"],"sourcesContent":["// Large Anime Scraper Service\r\n// Handles chunked scraping for anime with many episodes (like One Piece with 1146 episodes)\r\n\r\nexport interface LargeScrapeProgress {\r\n  id: string;\r\n  animeId: string;\r\n  animeTitle: string;\r\n  totalEpisodes: number;\r\n  completedEpisodes: number;\r\n  failedEpisodes: number;\r\n  currentChunk: number;\r\n  totalChunks: number;\r\n  chunkSize: number;\r\n  status: 'in_progress' | 'paused' | 'completed' | 'failed';\r\n  progressPercentage: number;\r\n  estimatedTimeRemaining: string;\r\n  episodesPerMs: number;\r\n  startedAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\nexport interface ChunkScrapeResult {\r\n  success: boolean;\r\n  message: string;\r\n  results: Array<{\r\n    episode: number;\r\n    status: 'success' | 'failed';\r\n    url?: string;\r\n    error?: string;\r\n  }>;\r\n  summary: {\r\n    totalEpisodes: number;\r\n    successCount: number;\r\n    errorCount: number;\r\n    successRate: number;\r\n  };\r\n}\r\n\r\nexport class LargeAnimeScraperService {\r\n  private static readonly API_BASE_URL = 'http://localhost:3001';\r\n\r\n  /**\r\n   * Start a large anime scraping job\r\n   */\r\n  static async startLargeScrape(\r\n    animeId: string,\r\n    animeTitle: string,\r\n    totalEpisodes: number,\r\n    chunkSize: number = 50\r\n  ): Promise<{\r\n    success: boolean;\r\n    message?: string;\r\n    jobId?: string;\r\n    totalEpisodes?: number;\r\n    totalChunks?: number;\r\n    chunkSize?: number;\r\n    error?: string;\r\n  }> {\r\n    try {\r\n      console.log(`🎬 Starting large scrape: ${animeTitle} (${totalEpisodes} episodes)`);\r\n\r\n      const response = await fetch(`${this.API_BASE_URL}/api/start-large-scrape`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          animeId,\r\n          animeTitle,\r\n          totalEpisodes,\r\n          chunkSize\r\n        })\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorData = await response.json();\r\n        throw new Error(errorData.error || `Server error: ${response.status}`);\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('Error starting large scrape:', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get scraping progress for an anime\r\n   */\r\n  static async getScrapingProgress(animeId: string): Promise<{\r\n    success: boolean;\r\n    progress?: LargeScrapeProgress;\r\n    error?: string;\r\n  }> {\r\n    try {\r\n      const response = await fetch(`${this.API_BASE_URL}/api/scraping-progress/${animeId}`);\r\n\r\n      if (!response.ok) {\r\n        const errorData = await response.json();\r\n        throw new Error(errorData.error || `Server error: ${response.status}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n      return {\r\n        success: true,\r\n        progress: data.progress\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting scraping progress:', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scrape a single chunk of episodes\r\n   */\r\n  static async scrapeChunk(\r\n    animeId: string,\r\n    animeTitle: string,\r\n    chunkNumber: number,\r\n    progressId: string,\r\n    totalEpisodes: number,\r\n    chunkSize: number = 50\r\n  ): Promise<ChunkScrapeResult> {\r\n    try {\r\n      console.log(`📺 Scraping chunk ${chunkNumber} for ${animeTitle}`);\r\n\r\n      const response = await fetch(`${this.API_BASE_URL}/api/scrape-chunk`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          animeId,\r\n          animeTitle,\r\n          chunkNumber,\r\n          progressId,\r\n          totalEpisodes,\r\n          chunkSize\r\n        })\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorData = await response.json();\r\n        throw new Error(errorData.error || `Server error: ${response.status}`);\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('Error scraping chunk:', error);\r\n      return {\r\n        success: false,\r\n        message: error instanceof Error ? error.message : 'Unknown error',\r\n        results: [],\r\n        summary: {\r\n          totalEpisodes: 0,\r\n          successCount: 0,\r\n          errorCount: 0,\r\n          successRate: 0\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scrape all chunks automatically (for background processing)\r\n   */\r\n  static async scrapeAllChunks(\r\n    animeId: string,\r\n    animeTitle: string,\r\n    totalEpisodes: number,\r\n    chunkSize: number = 50,\r\n    onProgress?: (progress: LargeScrapeProgress) => void,\r\n    onChunkComplete?: (chunkNumber: number, result: ChunkScrapeResult) => void\r\n  ): Promise<{\r\n    success: boolean;\r\n    message: string;\r\n    totalChunks: number;\r\n    completedChunks: number;\r\n    error?: string;\r\n  }> {\r\n    try {\r\n      // Start the large scrape job\r\n      const startResult = await this.startLargeScrape(animeId, animeTitle, totalEpisodes, chunkSize);\r\n      \r\n      if (!startResult.success) {\r\n        throw new Error(startResult.error || 'Failed to start large scrape');\r\n      }\r\n\r\n      const totalChunks = Math.ceil(totalEpisodes / chunkSize);\r\n      let completedChunks = 0;\r\n\r\n      console.log(`🚀 Starting automatic scraping of ${totalChunks} chunks`);\r\n\r\n      // Scrape each chunk\r\n      for (let chunkNumber = 1; chunkNumber <= totalChunks; chunkNumber++) {\r\n        try {\r\n          // Get current progress\r\n          const progressResult = await this.getScrapingProgress(animeId);\r\n          if (progressResult.success && onProgress) {\r\n            onProgress(progressResult.progress!);\r\n          }\r\n\r\n          // Scrape the chunk\r\n          const chunkResult = await this.scrapeChunk(\r\n            animeId,\r\n            animeTitle,\r\n            chunkNumber,\r\n            startResult.jobId!,\r\n            totalEpisodes,\r\n            chunkSize\r\n          );\r\n\r\n          completedChunks++;\r\n          \r\n          if (onChunkComplete) {\r\n            onChunkComplete(chunkNumber, chunkResult);\r\n          }\r\n\r\n          console.log(`✅ Chunk ${chunkNumber}/${totalChunks} completed: ${chunkResult.summary.successCount} success, ${chunkResult.summary.errorCount} failed`);\r\n\r\n          // Add delay between chunks to avoid being blocked\r\n          if (chunkNumber < totalChunks) {\r\n            console.log(`⏳ Waiting 10 seconds before next chunk...`);\r\n            await new Promise(resolve => setTimeout(resolve, 10000));\r\n          }\r\n\r\n        } catch (error) {\r\n          console.error(`❌ Chunk ${chunkNumber} failed:`, error);\r\n          // Continue with next chunk even if one fails\r\n        }\r\n      }\r\n\r\n      console.log(`🎉 All chunks completed! ${completedChunks}/${totalChunks} chunks processed`);\r\n\r\n      return {\r\n        success: true,\r\n        message: `Scraping completed: ${completedChunks}/${totalChunks} chunks processed`,\r\n        totalChunks,\r\n        completedChunks\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Error in scrapeAllChunks:', error);\r\n      return {\r\n        success: false,\r\n        message: 'Scraping failed',\r\n        totalChunks: 0,\r\n        completedChunks: 0,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate estimated time for large scraping\r\n   */\r\n  static calculateEstimatedTime(totalEpisodes: number, chunkSize: number = 50): {\r\n    totalChunks: number;\r\n    estimatedHours: number;\r\n    estimatedDays: number;\r\n  } {\r\n    const totalChunks = Math.ceil(totalEpisodes / chunkSize);\r\n    \r\n    // Estimate: 2 seconds per episode + 10 seconds between chunks\r\n    const secondsPerEpisode = 2;\r\n    const secondsBetweenChunks = 10;\r\n    \r\n    const totalSeconds = (totalEpisodes * secondsPerEpisode) + ((totalChunks - 1) * secondsBetweenChunks);\r\n    const estimatedHours = totalSeconds / 3600;\r\n    const estimatedDays = estimatedHours / 24;\r\n\r\n    return {\r\n      totalChunks,\r\n      estimatedHours: Math.round(estimatedHours * 10) / 10,\r\n      estimatedDays: Math.round(estimatedDays * 10) / 10\r\n    };\r\n  }\r\n}\r\n","import { useState, useEffect } from 'react';\nimport { LargeAnimeScraperService } from '../../services/largeAnimeScraperService';\nimport type { LargeScrapeProgress, ChunkScrapeResult } from '../../services/largeAnimeScraperService';\n\ninterface LargeAnimeScraperProps {\n  animeId: string;\n  animeTitle: string;\n  totalEpisodes: number;\n  onScrapingComplete?: () => void;\n}\n\nexport default function LargeAnimeScraper({\n  animeId,\n  animeTitle,\n  totalEpisodes,\n  onScrapingComplete\n}: LargeAnimeScraperProps) {\n  const [isScraping, setIsScraping] = useState(false);\n  const [progress, setProgress] = useState<LargeScrapeProgress | null>(null);\n  const [chunkSize, setChunkSize] = useState(50);\n  const [error, setError] = useState<string | null>(null);\n  const [success, setSuccess] = useState<string | null>(null);\n  const [recentChunkResults, setRecentChunkResults] = useState<ChunkScrapeResult[]>([]);\n\n  // Calculate estimated time\n  const estimatedTime = LargeAnimeScraperService.calculateEstimatedTime(totalEpisodes, chunkSize);\n\n  // Check for existing progress on mount\n  useEffect(() => {\n    checkExistingProgress();\n  }, [animeId]);\n\n  const checkExistingProgress = async () => {\n    try {\n      const result = await LargeAnimeScraperService.getScrapingProgress(animeId);\n      if (result.success && result.progress) {\n        setProgress(result.progress);\n        if (result.progress.status === 'in_progress') {\n          setIsScraping(true);\n        }\n      }\n    } catch (error) {\n      console.error('Error checking existing progress:', error);\n    }\n  };\n\n  const startScraping = async () => {\n    try {\n      setIsScraping(true);\n      setError(null);\n      setSuccess(null);\n      setRecentChunkResults([]);\n\n      const result = await LargeAnimeScraperService.scrapeAllChunks(\n        animeId,\n        animeTitle,\n        totalEpisodes,\n        chunkSize,\n        (progress) => {\n          setProgress(progress);\n        },\n        (_chunkNumber, chunkResult) => {\n          setRecentChunkResults(prev => [chunkResult, ...prev.slice(0, 4)]); // Keep last 5 results\n        }\n      );\n\n      if (result.success) {\n        setSuccess(`Scraping completed! ${result.completedChunks}/${result.totalChunks} chunks processed`);\n        if (onScrapingComplete) {\n          onScrapingComplete();\n        }\n      } else {\n        setError(result.error || 'Scraping failed');\n      }\n    } catch (error) {\n      setError(error instanceof Error ? error.message : 'Unknown error occurred');\n    } finally {\n      setIsScraping(false);\n    }\n  };\n\n  const pauseScraping = async () => {\n    // TODO: Implement pause functionality\n    setIsScraping(false);\n    setSuccess('Scraping paused');\n  };\n\n  const resumeScraping = async () => {\n    if (progress) {\n      // Resume from current chunk\n      await startScraping();\n    }\n  };\n\n  const resetScraping = async () => {\n    // TODO: Implement reset functionality\n    setProgress(null);\n    setRecentChunkResults([]);\n    setError(null);\n    setSuccess(null);\n  };\n\n  return (\n    <div className=\"bg-white rounded-lg shadow-lg p-6\">\n      <div className=\"flex items-center justify-between mb-6\">\n        <h3 className=\"text-xl font-bold text-gray-800\">\n          🎬 Large Anime Scraper\n        </h3>\n        <div className=\"text-sm text-gray-500\">\n          {totalEpisodes} episodes\n        </div>\n      </div>\n\n      {/* Anime Info */}\n      <div className=\"bg-gray-50 rounded-lg p-4 mb-6\">\n        <h4 className=\"font-semibold text-gray-800 mb-2\">{animeTitle}</h4>\n        <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 text-sm\">\n          <div>\n            <span className=\"text-gray-600\">Total Episodes:</span>\n            <div className=\"font-semibold\">{totalEpisodes}</div>\n          </div>\n          <div>\n            <span className=\"text-gray-600\">Chunk Size:</span>\n            <div className=\"font-semibold\">{chunkSize}</div>\n          </div>\n          <div>\n            <span className=\"text-gray-600\">Total Chunks:</span>\n            <div className=\"font-semibold\">{estimatedTime.totalChunks}</div>\n          </div>\n          <div>\n            <span className=\"text-gray-600\">Est. Time:</span>\n            <div className=\"font-semibold\">\n              {estimatedTime.estimatedDays > 1 \n                ? `${estimatedTime.estimatedDays} days`\n                : `${estimatedTime.estimatedHours} hours`\n              }\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Chunk Size Configuration */}\n      {!isScraping && !progress && (\n        <div className=\"mb-6\">\n          <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n            Chunk Size (episodes per batch)\n          </label>\n          <div className=\"flex items-center space-x-4\">\n            <input\n              type=\"range\"\n              min=\"10\"\n              max=\"100\"\n              value={chunkSize}\n              onChange={(e) => setChunkSize(parseInt(e.target.value))}\n              className=\"flex-1\"\n            />\n            <span className=\"text-sm font-semibold text-gray-600 min-w-[3rem]\">\n              {chunkSize}\n            </span>\n          </div>\n          <div className=\"text-xs text-gray-500 mt-1\">\n            Smaller chunks = more control, larger chunks = faster overall\n          </div>\n        </div>\n      )}\n\n      {/* Progress Display */}\n      {progress && (\n        <div className=\"mb-6\">\n          <div className=\"flex items-center justify-between mb-2\">\n            <span className=\"text-sm font-medium text-gray-700\">Progress</span>\n            <span className=\"text-sm text-gray-600\">\n              {progress.completedEpisodes}/{progress.totalEpisodes} episodes\n            </span>\n          </div>\n          <div className=\"w-full bg-gray-200 rounded-full h-3 mb-2\">\n            <div\n              className=\"bg-blue-600 h-3 rounded-full transition-all duration-300\"\n              style={{ width: `${progress.progressPercentage}%` }}\n            ></div>\n          </div>\n          <div className=\"flex justify-between text-xs text-gray-600\">\n            <span>{progress.progressPercentage}% complete</span>\n            <span>ETA: {progress.estimatedTimeRemaining}</span>\n          </div>\n          \n          {/* Detailed Stats */}\n          <div className=\"grid grid-cols-3 gap-4 mt-4 text-sm\">\n            <div className=\"text-center\">\n              <div className=\"text-green-600 font-semibold\">{progress.completedEpisodes}</div>\n              <div className=\"text-gray-600\">Completed</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-red-600 font-semibold\">{progress.failedEpisodes}</div>\n              <div className=\"text-gray-600\">Failed</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-blue-600 font-semibold\">{progress.currentChunk}/{progress.totalChunks}</div>\n              <div className=\"text-gray-600\">Chunks</div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Recent Chunk Results */}\n      {recentChunkResults.length > 0 && (\n        <div className=\"mb-6\">\n          <h4 className=\"text-sm font-medium text-gray-700 mb-3\">Recent Chunk Results</h4>\n          <div className=\"space-y-2\">\n            {recentChunkResults.map((result, index) => (\n              <div key={index} className=\"bg-gray-50 rounded p-3 text-sm\">\n                <div className=\"flex justify-between items-center\">\n                  <span className=\"font-medium\">\n                    {result.summary.successCount} success, {result.summary.errorCount} failed\n                  </span>\n                  <span className={`px-2 py-1 rounded text-xs ${\n                    result.summary.successRate >= 80 \n                      ? 'bg-green-100 text-green-800'\n                      : result.summary.successRate >= 50\n                      ? 'bg-yellow-100 text-yellow-800'\n                      : 'bg-red-100 text-red-800'\n                  }`}>\n                    {result.summary.successRate.toFixed(1)}%\n                  </span>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Action Buttons */}\n      <div className=\"flex flex-wrap gap-3\">\n        {!isScraping && !progress && (\n          <button\n            onClick={startScraping}\n            className=\"bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg font-medium transition-colors\"\n          >\n            🚀 Start Scraping\n          </button>\n        )}\n\n        {isScraping && (\n          <button\n            onClick={pauseScraping}\n            className=\"bg-yellow-600 hover:bg-yellow-700 text-white px-6 py-2 rounded-lg font-medium transition-colors\"\n          >\n            ⏸️ Pause\n          </button>\n        )}\n\n        {progress && !isScraping && progress.status !== 'completed' && (\n          <button\n            onClick={resumeScraping}\n            className=\"bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded-lg font-medium transition-colors\"\n          >\n            ▶️ Resume\n          </button>\n        )}\n\n        {(progress || recentChunkResults.length > 0) && (\n          <button\n            onClick={resetScraping}\n            className=\"bg-gray-600 hover:bg-gray-700 text-white px-6 py-2 rounded-lg font-medium transition-colors\"\n          >\n            🔄 Reset\n          </button>\n        )}\n      </div>\n\n      {/* Status Messages */}\n      {error && (\n        <div className=\"mt-4 bg-red-50 border border-red-200 rounded-lg p-4\">\n          <div className=\"flex items-center\">\n            <div className=\"text-red-600 mr-2\">❌</div>\n            <div className=\"text-red-800\">{error}</div>\n          </div>\n        </div>\n      )}\n\n      {success && (\n        <div className=\"mt-4 bg-green-50 border border-green-200 rounded-lg p-4\">\n          <div className=\"flex items-center\">\n            <div className=\"text-green-600 mr-2\">✅</div>\n            <div className=\"text-green-800\">{success}</div>\n          </div>\n        </div>\n      )}\n\n      {/* Warning */}\n      <div className=\"mt-6 bg-yellow-50 border border-yellow-200 rounded-lg p-4\">\n        <div className=\"flex items-start\">\n          <div className=\"text-yellow-600 mr-2 mt-0.5\">⚠️</div>\n          <div className=\"text-yellow-800 text-sm\">\n            <strong>Large scraping warning:</strong> This will take a significant amount of time. \n            For One Piece (1146 episodes), expect 6-12 hours depending on chunk size and delays. \n            The process can be paused and resumed. Make sure your server stays running.\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":["LargeAnimeScraperService","static","startLargeScrape","animeId","animeTitle","totalEpisodes","chunkSize","response","fetch","this","API_BASE_URL","method","headers","body","JSON","stringify","ok","errorData","json","Error","error","status","success","message","getScrapingProgress","progress","scrapeChunk","chunkNumber","progressId","results","summary","successCount","errorCount","successRate","scrapeAllChunks","onProgress","onChunkComplete","startResult","totalChunks","Math","ceil","completedChunks","progressResult","chunkResult","jobId","Promise","resolve","setTimeout","calculateEstimatedTime","estimatedHours","estimatedDays","round","LargeAnimeScraper","onScrapingComplete","isScraping","setIsScraping","useState","setProgress","setChunkSize","setError","setSuccess","recentChunkResults","setRecentChunkResults","estimatedTime","useEffect","checkExistingProgress","async","result","startScraping","_chunkNumber","prev","slice","jsxs","className","children","jsx","type","min","max","value","onChange","e","parseInt","target","completedEpisodes","style","width","progressPercentage","estimatedTimeRemaining","failedEpisodes","currentChunk","length","map","index","toFixed","onClick"],"mappings":"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"}