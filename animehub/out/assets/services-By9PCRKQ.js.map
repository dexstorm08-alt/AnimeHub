{"version":3,"file":"services-By9PCRKQ.js","sources":["../../src/services/animeService.ts","../../src/services/videoService.ts"],"sourcesContent":["import { supabase } from '../lib/supabase'\nimport type { Tables } from '../lib/supabase'\n\ntype Anime = Tables<'anime'>\ntype Episode = Tables<'episodes'>\n\nexport interface AnimeWithEpisodes extends Anime {\n  episodes?: Episode[]\n  user_progress?: any[]\n  is_favorited?: boolean\n  is_in_watchlist?: boolean\n}\n\n// Cache for frequently accessed data\nconst cache = new Map<string, { data: any; timestamp: number }>()\nconst CACHE_DURATION = 5 * 60 * 1000 // 5 minutes\n\n// Cache utility functions\nconst getCacheKey = (method: string, params: any) => \n  `${method}_${JSON.stringify(params)}`\n\nconst getCachedData = (key: string) => {\n  const cached = cache.get(key)\n  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {\n    return cached.data\n  }\n  return null\n}\n\nconst setCachedData = (key: string, data: any) => {\n  cache.set(key, { data, timestamp: Date.now() })\n}\n\nconst clearCache = () => {\n  cache.clear()\n}\n\nexport class AnimeService {\n  static async getAnimeList(page: number = 1, limit: number = 20, filters?: {\n    genre?: string\n    year?: number\n    status?: string\n    search?: string\n  }) {\n    try {\n      // Use the optimized search function for better performance\n      if (filters?.search || filters?.genre || filters?.year || filters?.status) {\n        const { data, error } = await supabase.rpc('search_anime_optimized', {\n          search_term: filters?.search || '',\n          genre_filter: filters?.genre || null,\n          year_filter: filters?.year || null,\n          status_filter: filters?.status || null,\n          type_filter: null,\n          rating_min: null,\n          limit_count: limit,\n          offset_count: (page - 1) * limit\n        })\n\n        if (error) {\n          console.error('Optimized search failed, falling back to regular query:', error)\n          // Fallback to regular query\n          return this.getAnimeListFallback(page, limit, filters)\n        }\n\n        // Get total count for pagination\n        const { count } = await supabase\n          .from('anime')\n          .select('*', { count: 'exact', head: true })\n          .modify((query) => {\n            if (filters?.genre) query.contains('genres', [filters.genre])\n            if (filters?.year) query.eq('year', filters.year)\n            if (filters?.status) query.eq('status', filters.status)\n            if (filters?.search) {\n              query.or(`title.ilike.%${filters.search}%,description.ilike.%${filters.search}%`)\n            }\n          })\n\n        return {\n          data: data || [],\n          total: count || 0,\n          page,\n          totalPages: Math.ceil((count || 0) / limit)\n        }\n      }\n\n      // For simple queries without filters, use regular query with count\n      const from = (page - 1) * limit\n      const to = from + limit - 1\n\n      const { data, error, count } = await supabase\n        .from('anime')\n        .select('*', { count: 'exact' })\n        .order('created_at', { ascending: false })\n        .range(from, to)\n\n      if (error) {\n        throw error\n      }\n\n      return {\n        data: data || [],\n        total: count || 0,\n        page,\n        totalPages: Math.ceil((count || 0) / limit)\n      }\n    } catch (error) {\n      console.error('Anime list fetch error:', error)\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\n      throw new Error(`Failed to fetch anime list: ${errorMessage}`)\n    }\n  }\n\n  // Fallback method for when optimized search fails\n  private static async getAnimeListFallback(page: number, limit: number, filters?: {\n    genre?: string\n    year?: number\n    status?: string\n    search?: string\n  }) {\n    let query = supabase\n      .from('anime')\n      .select('*', { count: 'exact' })\n      .order('created_at', { ascending: false })\n\n    // Apply filters\n    if (filters?.genre) {\n      query = query.contains('genres', [filters.genre])\n    }\n    if (filters?.year) {\n      query = query.eq('year', filters.year)\n    }\n    if (filters?.status) {\n      query = query.eq('status', filters.status)\n    }\n    if (filters?.search) {\n      query = query.or(`title.ilike.%${filters.search}%,description.ilike.%${filters.search}%`)\n    }\n\n    const from = (page - 1) * limit\n    const to = from + limit - 1\n\n    const { data, error, count } = await query.range(from, to)\n\n    if (error) {\n      throw error\n    }\n\n    return {\n      data: data || [],\n      total: count || 0,\n      page,\n      totalPages: Math.ceil((count || 0) / limit)\n    }\n  }\n\n  static async getFeaturedAnime(limit: number = 5) {\n    try {\n      const cacheKey = getCacheKey('featured_anime', { limit })\n      const cached = getCachedData(cacheKey)\n      \n      if (cached) {\n        return cached\n      }\n\n      // Use materialized view for better performance\n      const { data, error } = await supabase\n        .from('popular_anime')\n        .select('*')\n        .limit(limit)\n\n      if (error) {\n        // Fallback to regular query\n        const { data: fallbackData, error: fallbackError } = await supabase\n          .from('anime')\n          .select('*')\n          .gte('rating', 8.0)\n          .order('rating', { ascending: false })\n          .limit(limit)\n\n        if (fallbackError) {\n          console.error('Featured anime fetch error:', fallbackError)\n          throw new Error(`Failed to fetch featured anime: ${fallbackError.message}`)\n        }\n\n        const result = fallbackData || []\n        setCachedData(cacheKey, result)\n        return result\n      }\n\n      const result = data || []\n      setCachedData(cacheKey, result)\n      return result\n    } catch (error) {\n      console.error('Featured anime service error:', error)\n      return []\n    }\n  }\n\n  static async getTrendingAnime(limit: number = 10) {\n    try {\n      // Get anime that are both highly rated AND recently added\n      // This creates a \"trending\" effect by combining quality and freshness\n      const { data, error } = await supabase\n        .from('anime')\n        .select('*')\n        .gte('rating', 7.0)  // Good rating threshold\n        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())  // Added in last 30 days\n        .order('rating', { ascending: false })  // Order by highest rating first\n        .limit(limit)\n\n      if (error) {\n        console.error('Trending anime fetch error:', error)\n        throw new Error(`Failed to fetch trending anime: ${error.message}`)\n      }\n\n      // If we don't have enough recent anime, fallback to just high-rated anime\n      if (!data || data.length < limit) {\n        const { data: fallbackData, error: fallbackError } = await supabase\n          .from('anime')\n          .select('*')\n          .gte('rating', 7.5)\n          .order('rating', { ascending: false })\n          .limit(limit)\n\n        if (fallbackError) {\n          console.error('Trending anime fallback error:', fallbackError)\n          return data || []\n        }\n\n        return fallbackData || []\n      }\n\n      return data || []\n    } catch (error) {\n      console.error('Trending anime service error:', error)\n      return []\n    }\n  }\n\n  static async getPopularAnime(limit: number = 12) {\n    try {\n      const { data, error } = await supabase\n        .from('anime')\n        .select('*')\n        .gte('rating', 7.0)  // Lower threshold for more variety\n        .order('rating', { ascending: false })  // Order by highest rating\n        .limit(limit)\n\n      if (error) {\n        console.error('Popular anime fetch error:', error)\n        throw new Error(`Failed to fetch popular anime: ${error.message}`)\n      }\n\n      return data || []\n    } catch (error) {\n      console.error('Popular anime service error:', error)\n      return []\n    }\n  }\n\n  static async getAnimeById(animeId: string, userId?: string): Promise<AnimeWithEpisodes | null> {\n    try {\n      // Use a single query with joins for better performance\n      const { data: animeWithEpisodes, error: animeError } = await supabase\n        .from('anime')\n        .select(`\n          *,\n          episodes (*)\n        `)\n        .eq('id', animeId)\n        .single()\n\n      if (animeError || !animeWithEpisodes) {\n        console.error('Anime fetch error:', animeError)\n        return null\n      }\n\n      // Sort episodes by episode number\n      const sortedEpisodes = animeWithEpisodes.episodes?.sort((a: any, b: any) => \n        a.episode_number - b.episode_number\n      ) || []\n\n      const result: AnimeWithEpisodes = {\n        ...animeWithEpisodes,\n        episodes: sortedEpisodes\n      }\n\n      // Fetch user-specific data in parallel if userId is provided\n      if (userId) {\n        try {\n          const episodeIds = sortedEpisodes.map((e: any) => e.id)\n          \n          const [progressResult, favoritesResult, watchlistResult] = await Promise.all([\n            episodeIds.length > 0 ? supabase\n              .from('user_progress')\n              .select('*')\n              .eq('user_id', userId)\n              .in('episode_id', episodeIds) : Promise.resolve({ data: [] }),\n            \n            supabase\n              .from('user_favorites')\n              .select('id')\n              .eq('user_id', userId)\n              .eq('anime_id', animeId)\n              .maybeSingle(),\n            \n            supabase\n              .from('user_watchlist')\n              .select('id')\n              .eq('user_id', userId)\n              .eq('anime_id', animeId)\n              .maybeSingle()\n          ])\n\n          result.user_progress = progressResult.data || []\n          result.is_favorited = !!favoritesResult.data\n          result.is_in_watchlist = !!watchlistResult.data\n        } catch (userError) {\n          console.warn('User data fetch error (non-critical):', userError)\n          // Don't fail the entire request if user data fails\n          result.user_progress = []\n          result.is_favorited = false\n          result.is_in_watchlist = false\n        }\n      }\n\n      return result\n    } catch (error) {\n      console.error('getAnimeById service error:', error)\n      return null\n    }\n  }\n\n  static async createAnime(animeData: Partial<Anime>) {\n    const { data, error } = await supabase\n      .from('anime')\n      .insert(animeData)\n      .select()\n      .single()\n\n    if (error) {\n      throw new Error(`Failed to create anime: ${error.message}`)\n    }\n\n    return data\n  }\n\n  static async updateAnime(animeId: string, updates: Partial<Anime>) {\n    const { data, error } = await supabase\n      .from('anime')\n      .update({ ...updates, updated_at: new Date().toISOString() })\n      .eq('id', animeId)\n      .select()\n      .single()\n\n    if (error) {\n      throw new Error(`Failed to update anime: ${error.message}`)\n    }\n\n    return data\n  }\n\n  static async deleteAnime(animeId: string) {\n    const { error } = await supabase\n      .from('anime')\n      .delete()\n      .eq('id', animeId)\n\n    if (error) {\n      throw new Error(`Failed to delete anime: ${error.message}`)\n    }\n\n    return true\n  }\n\n  static async getGenres(): Promise<string[]> {\n    try {\n      const { data, error } = await supabase\n        .from('anime')\n        .select('genres')\n\n      if (error) {\n        console.error('Genres fetch error:', error)\n        throw new Error(`Failed to fetch genres: ${error.message}`)\n      }\n\n      const allGenres = data?.flatMap(anime => anime.genres || []) || []\n      const uniqueGenres = [...new Set(allGenres)].sort()\n      \n      return uniqueGenres\n    } catch (error) {\n      console.error('Genres service error:', error)\n      return []\n    }\n  }\n\n  static async searchAnime(query: string, limit: number = 20, filters?: {\n    genres?: string[]\n    year?: string\n    status?: string\n    sortBy?: string\n  }) {\n    try {\n      let searchQuery = supabase\n        .from('anime')\n        .select('*')\n\n      // Apply search query\n      if (query && query.trim()) {\n        searchQuery = searchQuery.or(`title.ilike.%${query}%,description.ilike.%${query}%,title_japanese.ilike.%${query}%`)\n      }\n\n      // Apply filters\n      if (filters?.genres && filters.genres.length > 0) {\n        searchQuery = searchQuery.contains('genres', filters.genres)\n      }\n      \n      if (filters?.year) {\n        searchQuery = searchQuery.eq('release_year', parseInt(filters.year))\n      }\n      \n      if (filters?.status) {\n        searchQuery = searchQuery.eq('status', filters.status)\n      }\n\n      // Apply sorting\n      switch (filters?.sortBy) {\n        case 'rating':\n          searchQuery = searchQuery.order('rating', { ascending: false })\n          break\n        case 'year':\n          searchQuery = searchQuery.order('release_year', { ascending: false })\n          break\n        case 'title':\n          searchQuery = searchQuery.order('title', { ascending: true })\n          break\n        case 'relevance':\n        default:\n          searchQuery = searchQuery.order('rating', { ascending: false })\n          break\n      }\n\n      const { data, error } = await searchQuery.limit(limit)\n\n      if (error) {\n        console.error('Search anime error:', error)\n        throw new Error(`Failed to search anime: ${error.message}`)\n      }\n\n      return data || []\n    } catch (error) {\n      console.error('Search anime service error:', error)\n      return []\n    }\n  }\n\n  static async getSimilarAnime(animeId: string, genres: string[], limit: number = 6): Promise<any[]> {\n    try {\n      if (!genres || genres.length === 0) {\n        return []\n      }\n\n      const { data, error } = await supabase\n        .from('anime')\n        .select('*')\n        .neq('id', animeId) // Exclude the current anime\n        .overlaps('genres', genres) // Find anime with overlapping genres\n        .order('rating', { ascending: false }) // Sort by rating\n        .limit(limit)\n\n      if (error) {\n        console.error('Get similar anime error:', error)\n        throw new Error(`Failed to get similar anime: ${error.message}`)\n      }\n\n      return data || []\n    } catch (error) {\n      console.error('Get similar anime service error:', error)\n      return []\n    }\n  }\n}","export type VideoSourceType = 'youtube' | 'direct' | 'hls' | 'iframe' | 'unknown';\n\nexport interface VideoSource {\n  quality: string;\n  url: string;\n  provider: string;\n  type: VideoSourceType;\n  embedUrl?: string;\n}\n\nexport interface VideoMetadata {\n  title: string;\n  description?: string;\n  duration?: number;\n  thumbnail?: string;\n  quality: string;\n}\n\nexport class VideoService {\n  /**\n   * Detect the type of video source from URL\n   */\n  static detectVideoSource(url: string): VideoSourceType {\n    if (!url) return 'unknown';\n    \n    const lowerUrl = url.toLowerCase();\n    \n    // YouTube detection\n    if (lowerUrl.includes('youtube.com') || lowerUrl.includes('youtu.be')) {\n      return 'youtube';\n    }\n    \n    // Anime streaming sites that require iframe embedding\n    if (lowerUrl.includes('anikai.to') || \n        lowerUrl.includes('9anime') || \n        lowerUrl.includes('zoro.to') ||\n        lowerUrl.includes('gogoanime') ||\n        lowerUrl.includes('megaplay.buzz') ||\n        lowerUrl.includes('megaplay') ||\n        lowerUrl.includes('2anime.xyz') ||\n        lowerUrl.includes('2m.2anime.xyz') ||\n        lowerUrl.includes('hianime.do') ||\n        lowerUrl.includes('crunchyroll.com')) {\n      return 'iframe';\n    }\n    \n    // HLS detection - enhanced for better .m3u8 recognition\n    if (lowerUrl.includes('.m3u8') || \n        lowerUrl.includes('hls') || \n        lowerUrl.includes('stream') ||\n        lowerUrl.match(/\\.m3u8(\\?|$|#)/)) {\n      return 'hls';\n    }\n    \n    // Direct video detection\n    if (lowerUrl.match(/\\.(mp4|webm|avi|mkv|mov|flv)$/i)) {\n      return 'direct';\n    }\n    \n    return 'unknown';\n  }\n\n  /**\n   * Extract YouTube video ID from various YouTube URL formats\n   */\n  static extractYouTubeId(url: string): string | null {\n    const patterns = [\n      /(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/|youtube\\.com\\/embed\\/|youtube\\.com\\/v\\/)([^&\\n?#]+)/,\n      /youtube\\.com\\/watch\\?.*v=([^&\\n?#]+)/,\n      /youtube\\.com\\/embed\\/([^&\\n?#]+)/\n    ];\n    \n    for (const pattern of patterns) {\n      const match = url.match(pattern);\n      if (match && match[1]) {\n        return match[1];\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Generate YouTube embed URL with optimal settings\n   */\n  static getYouTubeEmbedUrl(url: string, options: {\n    autoplay?: boolean;\n    start?: number;\n    quality?: string;\n    controls?: boolean;\n  } = {}): string {\n    const videoId = this.extractYouTubeId(url);\n    if (!videoId) {\n      throw new Error('Invalid YouTube URL');\n    }\n\n    const params = new URLSearchParams({\n      autoplay: options.autoplay ? '1' : '0',\n      controls: options.controls !== false ? '1' : '0',\n      rel: '0', // Don't show related videos\n      modestbranding: '1', // Minimal YouTube branding\n      fs: '1', // Allow fullscreen\n      cc_load_policy: '0', // Don't show captions by default\n      iv_load_policy: '3', // Hide annotations\n      playsinline: '1', // Play inline on mobile\n    });\n\n    if (options.start) {\n      params.set('start', options.start.toString());\n    }\n\n    if (options.quality) {\n      params.set('vq', options.quality);\n    }\n\n    return `https://www.youtube.com/embed/${videoId}?${params.toString()}`;\n  }\n\n  /**\n   * Generate proxy URL for direct video sources\n   */\n  static getDirectVideoProxyUrl(\n    originalUrl: string, \n    animeId: string, \n    episodeNumber: number,\n    options: {\n      quality?: string;\n      start?: number;\n    } = {}\n  ): string {\n    const params = new URLSearchParams({\n      url: originalUrl,\n      animeId,\n      episode: episodeNumber.toString(),\n    });\n\n    if (options.quality) {\n      params.set('quality', options.quality);\n    }\n\n    if (options.start) {\n      params.set('start', options.start.toString());\n    }\n\n    return `/api/video-proxy?${params.toString()}`;\n  }\n\n  /**\n   * Generate iframe embed URL for streaming sites\n   */\n  static getIframeEmbedUrl(url: string, options: {\n    autoplay?: boolean;\n    start?: number;\n    quality?: string;\n  } = {}): string {\n    // For anikai.to and similar sites, we need to use the URL as-is\n    // but add necessary parameters for embedding\n    const urlObj = new URL(url);\n    \n    // Add embedding parameters if supported\n    if (options.autoplay) {\n      urlObj.searchParams.set('autoplay', '1');\n    }\n    \n    if (options.start) {\n      urlObj.searchParams.set('t', options.start.toString());\n    }\n    \n    return urlObj.toString();\n  }\n\n  /**\n   * Check if URL is a streaming site page (not direct video)\n   */\n  static isStreamingSitePage(url: string): boolean {\n    const lowerUrl = url.toLowerCase();\n    return lowerUrl.includes('anikai.to/watch') || \n           lowerUrl.includes('9anime/watch') || \n           lowerUrl.includes('zoro.to/watch') ||\n           lowerUrl.includes('gogoanime/watch') ||\n           lowerUrl.includes('megaplay.buzz/watch');\n    // Note: HiAnime.do and megaplay.buzz are excluded here so they can be embedded directly\n  }\n\n  /**\n   * Generate external link fallback for streaming sites\n   */\n  static getExternalLinkFallback(url: string): { url: string; type: 'external' } {\n    return {\n      url: url,\n      type: 'external'\n    };\n  }\n\n  /**\n   * Process video source and return appropriate URL and metadata\n   */\n  static processVideoSource(\n    source: VideoSource,\n    animeId: string,\n    episodeNumber: number,\n    options: {\n      autoplay?: boolean;\n      start?: number;\n      quality?: string;\n    } = {}\n  ): { url: string; type: VideoSourceType; metadata: VideoMetadata } {\n    const sourceType = this.detectVideoSource(source.url);\n    \n    let processedUrl: string;\n    let metadata: VideoMetadata;\n\n    switch (sourceType) {\n      case 'youtube':\n        processedUrl = this.getYouTubeEmbedUrl(source.url, {\n          autoplay: options.autoplay,\n          start: options.start,\n          quality: options.quality,\n        });\n        metadata = {\n          title: `Episode ${episodeNumber}`,\n          quality: source.quality,\n          thumbnail: `https://img.youtube.com/vi/${this.extractYouTubeId(source.url)}/maxresdefault.jpg`\n        };\n        break;\n\n      case 'iframe':\n        // Check if this is a streaming site page (like anikai.to/watch/...)\n        if (this.isStreamingSitePage(source.url)) {\n          // For streaming site pages, we can't embed them properly\n          // Return the URL as-is for external link fallback\n          processedUrl = source.url;\n          metadata = {\n            title: `Episode ${episodeNumber}`,\n            quality: source.quality,\n          };\n        } else {\n          // For actual embed URLs, use iframe embedding\n          processedUrl = this.getIframeEmbedUrl(source.url, {\n            autoplay: options.autoplay,\n            start: options.start,\n            quality: options.quality,\n          });\n          metadata = {\n            title: `Episode ${episodeNumber}`,\n            quality: source.quality,\n          };\n        }\n        break;\n\n      case 'direct':\n      case 'hls':\n        processedUrl = this.getDirectVideoProxyUrl(source.url, animeId, episodeNumber, {\n          quality: options.quality,\n          start: options.start,\n        });\n        metadata = {\n          title: `Episode ${episodeNumber}`,\n          quality: source.quality,\n        };\n        break;\n\n      default:\n        processedUrl = source.url;\n        metadata = {\n          title: `Episode ${episodeNumber}`,\n          quality: source.quality,\n        };\n    }\n\n    return {\n      url: processedUrl,\n      type: sourceType,\n      metadata\n    };\n  }\n\n  /**\n   * Generate multiple quality sources for YouTube videos\n   */\n  static generateYouTubeQualities(url: string): VideoSource[] {\n    const videoId = this.extractYouTubeId(url);\n    if (!videoId) return [];\n\n    return [\n      {\n        quality: '1080p',\n        url: this.getYouTubeEmbedUrl(url, { quality: 'hd1080' }),\n        provider: 'YouTube',\n        type: 'youtube',\n        embedUrl: this.getYouTubeEmbedUrl(url, { quality: 'hd1080' })\n      },\n      {\n        quality: '720p',\n        url: this.getYouTubeEmbedUrl(url, { quality: 'hd720' }),\n        provider: 'YouTube',\n        type: 'youtube',\n        embedUrl: this.getYouTubeEmbedUrl(url, { quality: 'hd720' })\n      },\n      {\n        quality: '480p',\n        url: this.getYouTubeEmbedUrl(url, { quality: 'medium' }),\n        provider: 'YouTube',\n        type: 'youtube',\n        embedUrl: this.getYouTubeEmbedUrl(url, { quality: 'medium' })\n      },\n      {\n        quality: '360p',\n        url: this.getYouTubeEmbedUrl(url, { quality: 'small' }),\n        provider: 'YouTube',\n        type: 'youtube',\n        embedUrl: this.getYouTubeEmbedUrl(url, { quality: 'small' })\n      }\n    ];\n  }\n\n  /**\n   * Validate video URL accessibility\n   */\n  static async validateVideoUrl(url: string, sourceType: VideoSourceType): Promise<boolean> {\n    try {\n      if (sourceType === 'youtube') {\n        // For YouTube, check if video ID is valid\n        const videoId = this.extractYouTubeId(url);\n        return videoId !== null;\n      } else {\n        // For direct sources, try to fetch headers\n        const response = await fetch(url, { method: 'HEAD' });\n        return response.ok;\n      }\n    } catch (error) {\n      console.error('Video URL validation failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get video thumbnail for different source types\n   */\n  static getVideoThumbnail(url: string, sourceType: VideoSourceType): string {\n    switch (sourceType) {\n      case 'youtube':\n        const videoId = this.extractYouTubeId(url);\n        return videoId ? `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg` : '';\n      \n      case 'direct':\n      case 'hls':\n        // For direct sources, you might want to generate thumbnails\n        return '';\n      \n      default:\n        return '';\n    }\n  }\n\n  /**\n   * Parse video duration from various formats\n   */\n  static parseVideoDuration(duration: string | number): number {\n    if (typeof duration === 'number') {\n      return duration;\n    }\n\n    // Parse formats like \"1:23:45\" or \"23:45\" or \"45\"\n    const parts = duration.split(':').map(Number);\n    if (parts.length === 3) {\n      return parts[0] * 3600 + parts[1] * 60 + parts[2];\n    } else if (parts.length === 2) {\n      return parts[0] * 60 + parts[1];\n    } else {\n      return parts[0] || 0;\n    }\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds: number): string {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n\n    if (hours > 0) {\n      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n    } else {\n      return `${minutes}:${secs.toString().padStart(2, '0')}`;\n    }\n  }\n}\n"],"names":["cache","Map","setCachedData","key","data","set","timestamp","Date","now","AnimeService","getAnimeList","page","limit","filters","search","genre","year","status","error","supabase","rpc","search_term","genre_filter","year_filter","status_filter","type_filter","rating_min","limit_count","offset_count","this","getAnimeListFallback","count","from","select","head","modify","query","contains","eq","or","total","totalPages","Math","ceil","to","order","ascending","range","errorMessage","Error","message","getFeaturedAnime","cacheKey","params","JSON","stringify","cached","get","getCachedData","fallbackData","fallbackError","gte","result","getTrendingAnime","toISOString","length","getPopularAnime","getAnimeById","animeId","userId","animeWithEpisodes","animeError","single","sortedEpisodes","episodes","sort","a","b","episode_number","episodeIds","map","e","id","progressResult","favoritesResult","watchlistResult","Promise","all","in","resolve","maybeSingle","user_progress","is_favorited","is_in_watchlist","userError","createAnime","animeData","insert","updateAnime","updates","update","updated_at","deleteAnime","delete","getGenres","allGenres","flatMap","anime","genres","Set","searchAnime","searchQuery","trim","parseInt","sortBy","getSimilarAnime","neq","overlaps","VideoService","detectVideoSource","url","lowerUrl","toLowerCase","includes","match","extractYouTubeId","patterns","pattern","getYouTubeEmbedUrl","options","videoId","URLSearchParams","autoplay","controls","rel","modestbranding","fs","cc_load_policy","iv_load_policy","playsinline","start","toString","quality","getDirectVideoProxyUrl","originalUrl","episodeNumber","episode","getIframeEmbedUrl","urlObj","URL","searchParams","isStreamingSitePage","getExternalLinkFallback","type","processVideoSource","source","sourceType","processedUrl","metadata","title","thumbnail","generateYouTubeQualities","provider","embedUrl","validateVideoUrl","fetch","method","ok","getVideoThumbnail","parseVideoDuration","duration","parts","split","Number","formatDuration","seconds","hours","floor","minutes","secs","padStart"],"mappings":"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"}